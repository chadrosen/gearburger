#!/usr/bin/env ruby
require 'optparse'
require 'yaml'
require 'erb'

def parse_command_line
  # parse the command line args into a hash of options
  script_name = File.basename($0)
  options = {}
      
  ARGV.options do |o|
    o.banner = "Usage: #{script_name} [options]"
    o.define_head "Controls product generator process." 
           
    options[:run_type] = :all
        
    # TODO: add a -i for info on which workers are running  
    o.on("-e", "--env RAILS_ENV", String, "Rails environment") {|v| options[:env] = v }
    o.on_tail("-h", "--help", "Show this help message.") { puts o; exit }
    o.parse!
  end
  
  return options  
end

def main
  # process command line args
  options = parse_command_line
  
  # load the rails environment
  env = options[:env]
  ENV['RAILS_ENV'] = env if env
    
  require File.dirname(__FILE__) + '/../config/environment'
      
  brands = {}
  changes = 0
  
  Brand.find(:all).each do |b|

    # Does the brand already exist in our db?
    key = Brand.get_brand_key(b.name)
    
    # Is the current brand a dup? If so mark it so!!
    original_brand = brands.has_key?(key) ? brands[key] : nil
        
    if original_brand
      # It's a dup! You Bastards!!!
      
      # Update products with a new brand. Does not run if the new_brand is nil
      Product.update_all(["brand_id = ?", original_brand.id], ["brand_id = ?", b.id])
      
      # Move all of the users from one brand to another
      BrandsUser.update_all(["brand_id = ?", original_brand.id], ["brand_id = ?", b.id])
      
      # Map brand and inactivate old brand
      b.name = "#{b.name}_#{original_brand.id}_DUPLICATE"
      b.active = false
      b.save!
      
      puts "#{b.name} is a dup of #{original_brand.name}"
      
      changes += 1
    else
      # Nope. Go ahead and add it to the dict
      brands[key] = b
    end
    
  end
  
  puts "Total changes: #{changes}"
  
                                
end

if $0 == __FILE__
  main
end
