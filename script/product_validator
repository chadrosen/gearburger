#!/usr/bin/env ruby
require 'optparse'
require 'yaml'
require 'erb'

def parse_command_line
  # parse the command line args into a hash of options
  script_name = File.basename($0)
  options = {}
      
  ARGV.options do |o|
    o.banner = "Usage: #{script_name} [options]"
    o.define_head "Controls product validator process." 
           
    # Default
    options[:send_update] = false
        
    # TODO: add a -i for info on which workers are running  
    o.on("-l", "--limit limit", Integer, "Max amount of products to validate") { |v| options[:limit] = v }
    o.on("-e", "--env RAILS_ENV", String, "Rails environment") {|v| options[:env] = v }
    o.on("-u", "--send_update", "Send update email") { |v| options[:send_update] = true }
    o.on("-s", "--start_date start_date", String, "Start Date (yyyy-mm-dd hh:mm:ss)") { |v| options[:start_date] = v }
    o.on("-z", "--end_date end_date", String, "End Date (yyyy-mm-dd hh:mm:ss)") { |v| options[:end_date] = v }
    o.on_tail("-h", "--help", "Show this help message.") { puts o; exit }
    o.parse!
  end
  
  return options  
end

def main
  # process command line args
  options = parse_command_line
  
  # load the rails environment
  env = options[:env]
  ENV['RAILS_ENV'] = env if env
        
  require File.dirname(__FILE__) + '/../config/environment'

  require 'product_feed_matcher'
  p = ProductValidity::VerifyProduct.new(options)
  products = Product.get_changed_products(options)  
  p.validate_products!(products)
    
  #ProductNotificationMailer.deliver_product_email_results(sent, created, errors) if options[:send_update]
end

if $0 == __FILE__
  main
end